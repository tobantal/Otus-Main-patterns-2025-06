/**
 * @file AdapterCodeGenerator.cpp
 * @brief Реализация генератора кода адаптеров
 * @author Anton Tobolkin
 * @version 1.0
 */

#include "../../include/generators/AdapterCodeGenerator.hpp"
#include "../../include/utils/StringUtils.hpp"
#include <sstream>
#include <algorithm>
#include <set>
#include <iostream>

// Определение статических шаблонов
const std::string AdapterCodeGenerator::ADAPTER_TEMPLATE = R"(
/**
 * @file {ADAPTER_NAME}.hpp
 * @brief Auto-generated adapter for {INTERFACE_NAME}
 */

#pragma once

{INCLUDES}

/**
 * @brief Auto-generated adapter class for {INTERFACE_NAME}
 * 
 * This adapter implements the Adapter pattern to allow universal game objects
 * to be used through the {INTERFACE_NAME} interface using IoC container.
 */
class {ADAPTER_NAME} : public {FULL_INTERFACE_NAME} {
private:
    std::shared_ptr<IGameObject> m_gameObject; ///< Adapted game object

public:
    /**
     * @brief Constructor
     * @param gameObject Game object to adapt
     * @throws std::invalid_argument if gameObject is nullptr
     */
    explicit {ADAPTER_NAME}(std::shared_ptr<IGameObject> gameObject)
        : m_gameObject(gameObject) {
        if (!gameObject) {
            throw std::invalid_argument("Game object cannot be null");
        }
    }

    /**
     * @brief Destructor
     */
    ~{ADAPTER_NAME}() override = default;

{METHODS}
};
)";

const std::string AdapterCodeGenerator::GETTER_METHOD_TEMPLATE = R"(
    /**
     * @brief Get {PROPERTY_NAME} property
     * @return Value from IoC container
     */
    {RETURN_TYPE} {METHOD_NAME}(){CONST_QUALIFIER} override {
        try {
            return IoC::resolve<{RETURN_TYPE}>("{FULL_INTERFACE_NAME}:{PROPERTY_NAME}.get", m_gameObject);
        } catch (const std::exception& e) {
            throw std::runtime_error("Cannot get {PROPERTY_NAME}: " + std::string(e.what()));
        }
    }
)";

const std::string AdapterCodeGenerator::SETTER_METHOD_TEMPLATE = R"(
    /**
     * @brief Set {PROPERTY_NAME} property
     * @param value New value to set
     */
    void {METHOD_NAME}({PARAM_TYPE} value) override {
        try {
            auto command = IoC::resolve<ICommand>("{FULL_INTERFACE_NAME}:{PROPERTY_NAME}.set", 
                                                 m_gameObject, std::make_shared<{PARAM_TYPE_CLEAN}>(value));
            command->execute();
        } catch (const std::exception& e) {
            throw std::runtime_error("Cannot set {PROPERTY_NAME}: " + std::string(e.what()));
        }
    }
)";

const std::string AdapterCodeGenerator::VOID_METHOD_TEMPLATE = R"(
    /**
     * @brief Execute {METHOD_NAME} operation
     */
    void {METHOD_NAME}() override {
        try {
            auto command = IoC::resolve<ICommand>("{FULL_INTERFACE_NAME}:{METHOD_KEY}", m_gameObject);
            command->execute();
        } catch (const std::exception& e) {
            throw std::runtime_error("Cannot execute {METHOD_NAME}: " + std::string(e.what()));
        }
    }
)";

const std::string AdapterCodeGenerator::CUSTOM_METHOD_TEMPLATE = R"(
    /**
     * @brief {METHOD_NAME} with custom implementation
     * @note Uses custom implementation: {CUSTOM_REFERENCE}
     */
    {RETURN_TYPE} {METHOD_NAME}({PARAMETERS}){CONST_QUALIFIER} override {
        try {
            return {CUSTOM_REFERENCE}(m_gameObject{PARAMETER_PASS});
        } catch (const std::exception& e) {
            throw std::runtime_error("Cannot execute custom {METHOD_NAME}: " + std::string(e.what()));
        }
    }
)";

const std::string AdapterCodeGenerator::REGISTRATION_TEMPLATE = R"(
/**
 * @file AdapterRegistry.hpp
 * @brief Auto-generated adapter registration
 */

#pragma once

{INCLUDES}

namespace AutoGenerated {

/**
 * @brief Registry class for all auto-generated adapters
 */
class AdapterRegistry {
public:
    /**
     * @brief Register all adapters in IoC container
     */
    static void registerAll() {
{REGISTRATIONS}
    }

private:
    /**
     * @brief Register single adapter type
     * @tparam TInterface Interface type
     * @tparam TAdapter Adapter type
     * @param adapterKey Key for adapter factory registration
     * @param interfaceType Type info for interface
     */
    template<typename TInterface, typename TAdapter>
    static void registerAdapter(const std::string& adapterKey, const std::type_info& interfaceType) {
        // Создаем фабрику, которая принимает IGameObject и создает адаптер
        auto factory = std::make_shared<std::function<std::shared_ptr<TInterface>(std::shared_ptr<IGameObject>)>>(
            [](std::shared_ptr<IGameObject> obj) -> std::shared_ptr<TInterface> {
                return std::make_shared<TAdapter>(obj);
            }
        );
        
        // Регистрируем фабрику в IoC контейнере
        auto keyPtr = std::make_shared<std::string>(adapterKey);
        auto typePtr = std::make_shared<std::type_info>(interfaceType);
        
        std::vector<std::shared_ptr<void>> args = {keyPtr, typePtr, factory};
        
        auto registerCommand = IoC::resolve<ICommand>("IoC.Register", args);
        registerCommand->execute();
    }
};

} // namespace AutoGenerated
)";

std::string AdapterCodeGenerator::generateAdapter(const InterfaceInfo& interface) {
    variables_.clear();

    // Устанавливаем основные переменные
    variables_["INTERFACE_NAME"] = interface.className;
    variables_["FULL_INTERFACE_NAME"] = buildFullName(interface);
    variables_["ADAPTER_NAME"] = interface.getAdapterName();

    // Генерируем includes
    std::ostringstream includes;
    for (const auto& include : interface.getRequiredIncludes()) {
        includes << "#include \"" << include << "\"\n";
    }
    variables_["INCLUDES"] = includes.str();

    // Генерируем методы
    std::ostringstream methods;
    for (const auto& method : interface.methods) {
        methods << generateMethod(interface, method);
    }
    variables_["METHODS"] = methods.str();

    return renderTemplate(ADAPTER_TEMPLATE, variables_);
}

std::string AdapterCodeGenerator::generateRegistrationCode(
    const std::vector<InterfaceInfo>& interfaces) {
    
    std::map<std::string, std::string> vars;

    // Генерируем includes
    vars["INCLUDES"] = generateIncludes(interfaces);

    // Генерируем регистрации
    std::ostringstream registrations;
    for (const auto& interface : interfaces) {
        registrations << "        // Register " << interface.className << " adapter\n";
        registrations << "        registerAdapter<" << interface.getFullName() 
                     << ", " << interface.getAdapterName() 
                     << ">(\"Adapter:" << interface.getFullName() << "\", typeid(" << interface.getFullName() << "));\n\n";
    }
    vars["REGISTRATIONS"] = registrations.str();

    return renderTemplate(REGISTRATION_TEMPLATE, vars);
}

std::string AdapterCodeGenerator::buildFullName(const InterfaceInfo& interface) {
    return interface.getFullName();
}

std::string AdapterCodeGenerator::generateMethod(
    const InterfaceInfo& interface, 
    const MethodInfo& method) {
    
    if (method.hasCustomImplementation()) {
        return generateCustomMethod(interface, method);
    } else if (method.isGetter()) {
        return generateGetter(interface, method);
    } else if (method.isSetter()) {
        return generateSetter(interface, method);
    } else if (method.isVoidMethod()) {
        return generateVoidMethod(interface, method);
    } else {
        // Универсальная генерация IoC-метода
        return generateIoCMethod(interface, method);
    }
}

std::string AdapterCodeGenerator::generateIoCMethod(
    const InterfaceInfo& interface,
    const MethodInfo& method) {

    std::map<std::string, std::string> vars = variables_;
    vars["METHOD_NAME"] = method.name;
    vars["CONST_QUALIFIER"] = method.isConst ? " const" : "";
    vars["RETURN_TYPE"] = method.returnType;
    vars["METHOD_KEY"] = method.name;

    // Формируем параметры сигнатуры и передачи
    std::ostringstream params;
    std::ostringstream paramPass;
    for (size_t i = 0; i < method.parameters.size(); ++i) {
        if (i > 0) {
            params << ", ";
            paramPass << ", ";
        }
        params << method.parameters[i];
        // Извлечь имя параметра
        std::string p = method.parameters[i];
        auto pos = p.find_last_of(' ');
        paramPass << (pos == std::string::npos ? p : p.substr(pos + 1));
    }
    vars["PARAMETERS"] = params.str();
    vars["PARAMETER_PASS"] = paramPass.str().empty() ? "" : ", " + paramPass.str();

    // Выбрать шаблон: void или non-void
    const std::string& tmpl = (method.returnType == "void")
        ? R"(
    /**
     * @brief Execute {METHOD_NAME} operation
     */
    void {METHOD_NAME}({PARAMETERS}){CONST_QUALIFIER} override {
        try {
            auto command = IoC::resolve<ICommand>("{INTERFACE_NAME}:{METHOD_KEY}", m_gameObject{PARAMETER_PASS});
            command->execute();
        } catch (const std::exception& e) {
            throw std::runtime_error("Cannot execute {METHOD_NAME}: " + std::string(e.what()));
        }
    }
)"
        : R"(
    /**
     * @brief Execute {METHOD_NAME} operation
     * @return {RETURN_TYPE} from IoC container
     */
    {RETURN_TYPE} {METHOD_NAME}({PARAMETERS}){CONST_QUALIFIER} override {
        try {
            return IoC::resolve<{RETURN_TYPE}>("{INTERFACE_NAME}:{METHOD_KEY}", m_gameObject{PARAMETER_PASS});
        } catch (const std::exception& e) {
            throw std::runtime_error("Cannot execute {METHOD_NAME}: " + std::string(e.what()));
        }
    }
)";

    return renderTemplate(tmpl, vars);
}

std::string AdapterCodeGenerator::generateGetter(
    const InterfaceInfo& interface, 
    const MethodInfo& method) {
    
    std::map<std::string, std::string> vars = variables_;
    vars["RETURN_TYPE"] = method.returnType;
    vars["METHOD_NAME"] = method.name;
    vars["PROPERTY_NAME"] = method.getPropertyName();
    vars["CONST_QUALIFIER"] = method.isConst ? " const" : "";

    return renderTemplate(GETTER_METHOD_TEMPLATE, vars);
}

std::string AdapterCodeGenerator::generateSetter(
    const InterfaceInfo& interface, const MethodInfo& method) {
    
    std::map<std::string, std::string> vars = variables_;
    vars["METHOD_NAME"] = method.name;
    vars["PARAM_TYPE"] = extractParamType(method.parameters[0]);
    vars["PARAM_TYPE_CLEAN"] = StringUtils::replaceAll(vars["PARAM_TYPE"], "const ", "");
    vars["PARAM_TYPE_CLEAN"] = StringUtils::replaceAll(vars["PARAM_TYPE_CLEAN"], "&", "");
    vars["PARAM_TYPE_CLEAN"] = StringUtils::trim(vars["PARAM_TYPE_CLEAN"]);
    vars["PROPERTY_NAME"] = method.getPropertyName();

    return renderTemplate(SETTER_METHOD_TEMPLATE, vars);
}

std::string AdapterCodeGenerator::generateVoidMethod(
    const InterfaceInfo& interface, 
    const MethodInfo& method) {
    
    std::map<std::string, std::string> vars = variables_;
    vars["METHOD_NAME"] = method.name;
    vars["METHOD_KEY"] = method.name;

    return renderTemplate(VOID_METHOD_TEMPLATE, vars);
}

std::string AdapterCodeGenerator::generateCustomMethod(
    const InterfaceInfo& interface, 
    const MethodInfo& method) {
    
    std::map<std::string, std::string> vars = variables_;
    vars["METHOD_NAME"] = method.name;
    vars["RETURN_TYPE"] = method.returnType;
    vars["CUSTOM_REFERENCE"] = method.customImpl.getFullReference();
    vars["CONST_QUALIFIER"] = method.isConst ? " const" : "";

    // Генерируем параметры
    std::ostringstream params;
    std::ostringstream paramPass;
    
    for (size_t i = 0; i < method.parameters.size(); ++i) {
        if (i > 0) {
            params << ", ";
            paramPass << ", ";
        }
        params << method.parameters[i];
        
        // Извлекаем имя параметра из объявления
        std::string paramName = method.parameters[i];
        size_t lastSpace = paramName.find_last_of(' ');
        if (lastSpace != std::string::npos) {
            paramName = paramName.substr(lastSpace + 1);
        }
        paramPass << paramName;
    }
    
    vars["PARAMETERS"] = params.str();
    vars["PARAMETER_PASS"] = paramPass.str().empty() ? "" : ", " + paramPass.str();

    return renderTemplate(CUSTOM_METHOD_TEMPLATE, vars);
}

std::string AdapterCodeGenerator::extractParamType(const std::string& param) {
    // Ищем последний пробел - после него должно быть имя параметра
    size_t lastSpace = param.find_last_of(' ');
    if (lastSpace != std::string::npos) {
        return StringUtils::trim(param.substr(0, lastSpace));
    }
    return param; // Если пробела нет, возвращаем весь параметр
}

std::string AdapterCodeGenerator::renderTemplate(
    const std::string& templateStr,
    const std::map<std::string, std::string>& vars) {
    
    std::string result = templateStr;
    for (const auto& [key, value] : vars) {
        std::string placeholder = "{" + key + "}";
        result = StringUtils::replaceAll(result, placeholder, value);
    }

    std::cout << result << std::endl;

    return result;
}

std::string AdapterCodeGenerator::generateIncludes(const std::vector<InterfaceInfo>& interfaces) {
    std::set<std::string> uniqueIncludes;
    
    for (const auto& interface : interfaces) {
        // include интерфейса
        uniqueIncludes.insert(interface.className + ".hpp");
        // include адаптера
        uniqueIncludes.insert(interface.getAdapterName() + ".hpp");
    }

    // стандартные зависимости
    uniqueIncludes.insert("ICommand.hpp");
    uniqueIncludes.insert("IoC.hpp");

    std::ostringstream result;
    for (const auto& include : uniqueIncludes) {
        result << "#include \"" << include << "\"\n";
    }
    return result.str();
}
