# Конспект: Генерация адаптеров по интерфейсу (C++17)

## Обзор задания

**Цель**: Создать препроцессор для автоматической генерации адаптеров по абстрактным классам (интерфейсам) в C++17, демонстрируя применение метапрограммирования для решения рутинных задач.

**Контекст**: Применение принципа DIP (Dependency Inversion Principle) приводит к созданию множества интерфейсов, для которых требуется написание большого количества однотипного кода адаптеров.

## Архитектурные принципы и паттерны

### Паттерн Адаптер

**Определение**: Структурный паттерн, позволяющий объектам с несовместимыми интерфейсами работать вместе.

**Диаграмма классов**:
```
Client -> Target (+request())
            ↑
        Adapter (+request()) -> Adaptee (+specificRequest())
                                  ↑
                              «adaptee»
```

**Применение в контексте DIP**:
- Множество интерфейсов для различных аспектов игровых объектов
- Необходимость адаптации универсальных объектов к специфическим интерфейсам
- Избежание мутабельности через использование адаптеров

### Принцип инверсии зависимостей (DIP)

**Проблема**: 
```cpp
class Spaceship {
    // Жесткая связанность - нарушает SOLID
    Engine* engine = new Engine();
    Weapon* weapon = new Weapon();
};
```

**Решение через интерфейсы**:
```cpp
// Множество специализированных интерфейсов
class IMovable { virtual Vector getPosition() = 0; };
class IRotatable { virtual int getDirection() = 0; };
class IFuelable { virtual int getFuelLevel() = 0; };
```

## Задача генерации адаптеров

### Исходный интерфейс (пример)
```cpp
interface Spaceship.Operations.IMovable {
    Vector getPosition();
    void setPosition(Vector newValue);
    Vector getVelocity();
}
```

### Требуемый результат генерации
```cpp
class AutoGenerated::MovableAdapter : public Spaceship::Operations::IMovable {
    UObject* obj;
    
public:
    MovableAdapter(UObject* obj) : obj(obj) {}
    
    Vector getPosition() override {
        return IoC::resolve<Vector>("Spaceship.Operations.IMovable:position.get", obj);
    }
    
    Vector getVelocity() override {
        return IoC::resolve<Vector>("Spaceship.Operations.IMovable:velocity.get", obj);
    }
    
    void setPosition(Vector newValue) override {
        IoC::resolve<ICommand>("Spaceship.Operations.IMovable:position.set", obj, newValue)->execute();
    }
};
```

### Интеграция с IoC контейнером
```cpp
// Создание экземпляра адаптера через IoC
auto adapter = IoC::resolve<IMovable>("Adapter", typeid(IMovable), obj);
```

## Техническая реализация на C++17

### 1. Архитектура препроцессора

**Этапы обработки**:
1. **Парсинг** - анализ заголовочных файлов для поиска абстрактных классов
2. **Анализ** - извлечение информации о методах интерфейса
3. **Генерация** - создание кода адаптера по шаблону
4. **Интеграция** - включение сгенерированного кода в проект

**Структура препроцессора**:
```cpp
class AdapterGenerator {
public:
    struct MethodInfo {
        std::string returnType;
        std::string name;
        std::vector<Parameter> parameters;
        bool isConst;
        bool isPureVirtual;
    };
    
    struct InterfaceInfo {
        std::string namespaceName;
        std::string className;
        std::vector<MethodInfo> methods;
    };
    
    std::string generateAdapter(const InterfaceInfo& interface);
};
```

### 2. Поиск абстрактных классов

**Критерии идентификации**:
```cpp
class InterfaceDetector {
    bool isInterface(const CXXRecordDecl* record) {
        // Проверяем наличие чисто виртуальных методов
        for (auto method : record->methods()) {
            if (method->isPure()) return true;
        }
        return false;
    }
    
    bool hasOnlyPureVirtualMethods(const CXXRecordDecl* record) {
        // Проверяем, что все виртуальные методы чисто виртуальные
        for (auto method : record->methods()) {
            if (method->isVirtual() && !method->isPure()) {
                return false;
            }
        }
        return true;
    }
};
```

### 3. Шаблон генерации кода

**Основанный на текстовых шаблонах**:
```cpp
const std::string ADAPTER_TEMPLATE = R"(
class AutoGenerated::{INTERFACE_NAME}Adapter : public {FULL_INTERFACE_NAME} {
private:
    UObject* obj_;
    
public:
    explicit {INTERFACE_NAME}Adapter(UObject* obj) : obj_(obj) {
        if (!obj) throw std::invalid_argument("Object cannot be null");
    }
    
{METHODS}
};
)";

const std::string GETTER_METHOD_TEMPLATE = R"(
    {RETURN_TYPE} {METHOD_NAME}() const override {
        return IoC::resolve<{RETURN_TYPE}>("{INTERFACE_NAME}:{PROPERTY_NAME}.get", obj_);
    }
)";

const std::string SETTER_METHOD_TEMPLATE = R"(
    void {METHOD_NAME}(const {PARAM_TYPE}& value) override {
        IoC::resolve<ICommand>("{INTERFACE_NAME}:{PROPERTY_NAME}.set", obj_, value)->execute();
    }
)";
```

### 4. Интеграция с системой сборки

**CMakeLists.txt интеграция**:
```cmake
# Генерация адаптеров как пререквизит для компиляции
find_program(ADAPTER_GENERATOR adapter_generator PATHS ${CMAKE_BINARY_DIR}/tools)

# Поиск всех заголовочных файлов с интерфейсами
file(GLOB_RECURSE INTERFACE_HEADERS "include/*Interface*.hpp" "include/I*.hpp")

# Создание custom target для генерации адаптеров
add_custom_command(
    OUTPUT ${CMAKE_BINARY_DIR}/generated/adapters.cpp
    COMMAND ${ADAPTER_GENERATOR} 
        --input-dir ${CMAKE_SOURCE_DIR}/include
        --output ${CMAKE_BINARY_DIR}/generated/adapters.cpp
        --namespace AutoGenerated
    DEPENDS ${INTERFACE_HEADERS}
    COMMENT "Generating interface adapters"
)

# Добавление сгенерированного кода к целевому объекту
target_sources(${PROJECT_NAME} PRIVATE ${CMAKE_BINARY_DIR}/generated/adapters.cpp)

# Очистка сгенерированных файлов при make clean
set_directory_properties(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES 
    "${CMAKE_BINARY_DIR}/generated")
```

### 5. Обработка специальных случаев

**Методы без параметров**:
```cpp
std::string generateSimpleMethod(const MethodInfo& method) {
    if (method.returnType == "void") {
        return formatTemplate(VOID_METHOD_TEMPLATE, {
            {"METHOD_NAME", method.name},
            {"INTERFACE_NAME", interfaceName},
            {"METHOD_KEY", method.name}
        });
    }
    return formatTemplate(GETTER_METHOD_TEMPLATE, {
        {"RETURN_TYPE", method.returnType},
        {"METHOD_NAME", method.name},
        {"INTERFACE_NAME", interfaceName},
        {"PROPERTY_NAME", extractPropertyName(method.name)}
    });
}
```

**Обработка методов типа `void finish()`**:
```cpp
const std::string VOID_METHOD_TEMPLATE = R"(
    void {METHOD_NAME}() override {
        IoC::resolve<ICommand>("{INTERFACE_NAME}:{METHOD_KEY}", obj_)->execute();
    }
)";
```

## Стратегия для IoC контейнера

### Регистрация генератора адаптеров
```cpp
// Стратегия создания адаптеров
class AdapterCreationStrategy {
public:
    template<typename TInterface>
    static std::shared_ptr<TInterface> createAdapter(
        const std::string& interfaceName, 
        std::shared_ptr<void> obj) {
        
        std::string adapterKey = "Adapter:" + interfaceName;
        
        // Поиск фабрики адаптера в IoC
        auto factory = IoC::resolve<AdapterFactory<TInterface>>(adapterKey);
        return factory->create(obj);
    }
};

// Регистрация в IoC контейнере
IoC::resolve<ICommand>("IoC.Register", 
    "Adapter", 
    [](const std::string& interfaceType, std::shared_ptr<void> obj) {
        return AdapterCreationStrategy::createAdapter(interfaceType, obj);
    }
)->execute();
```

### Автоматическая регистрация сгенерированных адаптеров
```cpp
// Автогенерируемая регистрация адаптеров
namespace AutoGenerated {
    class AdapterRegistration {
    public:
        static void registerAll() {
            // Регистрация MovableAdapter
            IoC::resolve<ICommand>("IoC.Register",
                "Adapter:IMovable",
                [](std::shared_ptr<void> obj) -> std::shared_ptr<IMovable> {
                    auto gameObj = std::static_pointer_cast<UObject>(obj);
                    return std::make_shared<MovableAdapter>(gameObj.get());
                }
            )->execute();
            
            // Аналогично для других интерфейсов...
        }
    };
}
```

## Инструменты и технологии

### 1. Парсинг C++ кода

**Libclang**:
```cpp
#include <clang-c/Index.h>

class ClangParser {
public:
    std::vector<InterfaceInfo> parseInterfaces(const std::string& filePath) {
        CXIndex index = clang_createIndex(0, 0);
        CXTranslationUnit unit = clang_parseTranslationUnit(
            index, filePath.c_str(), nullptr, 0, nullptr, 0,
            CXTranslationUnit_None);
            
        std::vector<InterfaceInfo> interfaces;
        CXCursor cursor = clang_getTranslationUnitCursor(unit);
        clang_visitChildren(cursor, [](CXCursor cursor, CXCursor parent, CXClientData client_data) {
            auto* interfaces = static_cast<std::vector<InterfaceInfo>*>(client_data);
            
            if (clang_getCursorKind(cursor) == CXCursor_ClassDecl) {
                if (isInterface(cursor)) {
                    interfaces->push_back(extractInterfaceInfo(cursor));
                }
            }
            return CXChildVisit_Continue;
        }, &interfaces);
        
        clang_disposeTranslationUnit(unit);
        clang_disposeIndex(index);
        return interfaces;
    }
};
```

**Альтернатива - простой регекс парсер**:
```cpp
class SimpleParser {
    std::regex interfaceRegex{R"(class\s+(\w+)\s*\{[^}]*virtual[^}]*=\s*0)"};
    std::regex methodRegex{R"(virtual\s+(.+?)\s+(\w+)\s*\([^)]*\)\s*(?:const)?\s*=\s*0)"};
    
public:
    std::vector<InterfaceInfo> parseFile(const std::string& content);
};
```

### 2. Генерация кода

**Система шаблонов**:
```cpp
class TemplateEngine {
private:
    std::map<std::string, std::string> variables_;
    
public:
    void setVariable(const std::string& name, const std::string& value) {
        variables_[name] = value;
    }
    
    std::string render(const std::string& template_text) {
        std::string result = template_text;
        for (const auto& [key, value] : variables_) {
            std::string placeholder = "{" + key + "}";
            size_t pos = 0;
            while ((pos = result.find(placeholder, pos)) != std::string::npos) {
                result.replace(pos, placeholder.length(), value);
                pos += value.length();
            }
        }
        return result;
    }
};
```

## Тестирование генератора

### Unit-тесты генерации
```cpp
TEST(AdapterGeneratorTest, GeneratesBasicAdapter) {
    InterfaceInfo interface;
    interface.className = "IMovable";
    interface.namespaceName = "Spaceship::Operations";
    
    MethodInfo getPos;
    getPos.returnType = "Vector";
    getPos.name = "getPosition";
    getPos.isConst = true;
    interface.methods.push_back(getPos);
    
    AdapterGenerator generator;
    std::string result = generator.generateAdapter(interface);
    
    EXPECT_THAT(result, HasSubstr("class MovableAdapter"));
    EXPECT_THAT(result, HasSubstr("Vector getPosition()"));
    EXPECT_THAT(result, HasSubstr("IoC::resolve<Vector>"));
}
```

### Интеграционные тесты
```cpp
TEST(AdapterIntegrationTest, GeneratedAdapterWorksWithIoC) {
    // Генерируем адаптер
    generateAdaptersForProject();
    
    // Компилируем проект
    ASSERT_TRUE(compileProject());
    
    // Тестируем работу адаптера
    auto gameObject = std::make_shared<TestGameObject>();
    auto adapter = IoC::resolve<IMovable>("Adapter", typeid(IMovable), gameObject);
    
    EXPECT_NO_THROW(adapter->getPosition());
}
```

## Критерии успешной реализации

### Функциональные требования (10 баллов)
- [x] **Задание сдано на проверку** (1 балл)
- [x] **Реализован генератор адаптеров** (3 балла)
  - Поиск абстрактных классов в заголовочных файлах
  - Анализ методов интерфейсов
  - Генерация корректного кода адаптеров
- [x] **Реализованы тесты на генератор** (2 балла)
  - Unit-тесты парсинга интерфейсов
  - Тесты генерации кода по шаблонам
  - Интеграционные тесты с IoC контейнером
- [x] **Определена стратегия для IoC** (2 балла)
  - Автоматическая регистрация адаптеров
  - Фабричные методы создания адаптеров
- [x] **Обработан случай void методов** (2 балла)
  - Поддержка методов без возвращаемого значения
  - Правильная генерация команд для выполнения

### Архитектурные требования
- **Соблюдение принципов SOLID**
- **Использование современных возможностей C++17**
- **Интеграция с системой сборки CMake**
- **Поддержка кросс-платформенной компиляции**

## Практические соображения

### Ограничения и компромиссы
1. **Сложность парсинга C++** - может потребовать полноценного парсера
2. **Зависимость от IoC контейнера** - тесная связь с конкретной реализацией
3. **Время компиляции** - генерация кода может замедлить сборку
4. **Отладка** - сгенерированный код сложнее отлаживать

### Рекомендации по развитию
1. **Расширение шаблонов** - поддержка более сложных паттернов методов
2. **Кэширование** - сохранение результатов генерации при неизменных интерфейсах
3. **IDE интеграция** - поддержка автодополнения для сгенерированных адаптеров
4. **Документация** - автогенерация документации для адаптеров

## Заключение

Генерация адаптеров по интерфейсу представляет собой практическое применение метапрограммирования для решения архитектурных задач. Это решение:

- **Устраняет дублирование кода** при создании множества адаптеров
- **Повышает сопровождаемость** за счет автоматической синхронизации с интерфейсами  
- **Демонстрирует возможности C++17** для создания инструментов разработки
- **Интегрируется с современными практиками** сборки и тестирования

Успешная реализация требует понимания как технических аспектов (парсинг, генерация кода), так и архитектурных принципов (SOLID, IoC, паттерны проектирования).